{"version":3,"sources":["webpack:///XLSXExportUtils.js","webpack:///webpack/bootstrap ec45a77245af68849c0d","webpack:///./client/src/export-utils.js","webpack:///./client/src/provider/ODataDataProvider.js","webpack:///./client/src/provider/RequestHandler.js","webpack:///./client/src/filesaver/FileSaver.js"],"names":["XLSXExportUtils","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","33","ODataDataProvider","FileSaver","oData","fetch","requestData","getConverter","saveFile","34","getValue","oRow","oCol","keys","reduce","obj","key","convertData","aRows","aCols","forEach","col","row","getColsToConvert","mSettings","workbook","columns","result","Array","aKeys","split","length","push","type","getDataConverter","aColumns","fnProcessCallback","getUrl","iSkip","iTop","sNextUrl","mDataUrl","URI","parse","dataUrl","mNextUrl","query","aQuery","mQuery","keyValue","join","serialize","build","fnOnError","sMessage","error","fnOnDataReceived","oResult","aData","iFetchedRows","fPercent","iRemainingRows","mCallbackParams","bCancelled","results","isArray","iAvailableRows","iTotalRows","finished","progress","Math","round","__next","mRequest","min","iBatchSize","RequestHandler","sendRequest","then","catch","rows","fnConvertData","mDataSource","dataSource","count","MAX_ROWS","sizeLimit","batchSize","serviceUrl","url","mUri","path","slice","hash","fragment","method","useBatch","headers","cancel","35","oRequest","Error","sendBatchRequest","sendGetRequest","Promise","fnResolve","fnReject","xhr","XMLHttpRequest","onload","this","status","responseText","JSON","e","HTTP_WRONG_RESPONSE_MSG","onerror","HTTP_ERROR_MSG","onabort","open","setRequestHeader","send","createGuid","replace","r","random","toString","boundary","body","aLines","iStart","iLength","iEnd","responseData","toLowerCase","36","blob","link","downloadSupported","fnSave","Blob","document","createElementNS","data","fileName","download","href","URL","createObjectURL","dispatchEvent","MouseEvent","reader","FileReader","onloadend","opened","window","location","readAsDataURL","navigator","msSaveOrOpenBlob"],"mappings":"AAAA,GAAIA,iBACK,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA4DA,OAhCAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,SAAAP,EAAAQ,EAAAC,GACAZ,EAAAa,EAAAV,EAAAQ,IACAG,OAAAC,eAAAZ,EAAAQ,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAf,GACA,GAAAQ,GAAAR,KAAAgB,WACA,WAA2B,MAAAhB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDtB,EAAAyB,EAAA,GAGAzB,IAAA0B,EAAA,MDOMC,GACA,SAAUvB,EAAQD,EAASH,GEpEjC,GAAA4B,GAAA5B,EAAA,IACA6B,EAAA7B,EAAA,GAEAI,GAAAD,SACA2B,OACAC,MAAAH,EAAAI,YACAC,aAAAL,EAAAK,cAEAC,SAAAL,EAAAK,WF4EMC,GACA,SAAU/B,EAAQD,EAASH,GGnEjC,QAAAoC,GAAAC,EAAAC,GAMA,MAJAA,GAAAC,KAAAC,OAAA,SAAAC,EAAAC,GACA,MAAAD,MAAAC,IACEL,GAaF,QAAAM,GAAAC,EAAAC,GAMA,MALAA,GAAAC,QAAA,SAAAC,GACAH,EAAAE,QAAA,SAAAE,GACAA,EAAAD,EAAAzB,UAAAc,EAAAY,EAAAD,OAGAH,EASA,QAAAK,GAAAC,GACA,MAAAA,GAAAC,SAAAC,QAAAZ,OAAA,SAAAa,EAAAN,GAiBA,OAdAA,EAAAzB,mBAAAgC,OAAAP,EAAAzB,UAAAyB,EAAAzB,WAEAwB,QAAA,SAAAxB,GAEA,GAAAiC,GAAAjC,EAAAkC,MAAA,IACAD,GAAAE,OAAA,GACAJ,EAAAK,MACApC,WACAiB,KAAAgB,EACAI,KAAAZ,EAAAY,SAKAN,OAUA,QAAAO,GAAAV,GACA,GAAAW,GAAAZ,EAAAC,EACA,iBAAAN,GACA,MAAAD,GAAAC,EAAAiB,IAUA,QAAA7B,GAAAkB,EAAAY,GAwBA,QAAAC,GAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAAC,IAAAC,MAAAC,EACA,IAAAJ,EAAA,CACA,GAAAK,GAAAH,IAAAC,MAAAH,EACAC,GAAAK,MAAAD,EAAAC,UACG,CACH,GAAAC,IAAAN,EAAAK,OAAA,IAAAhB,MAAA,KACAkB,IACAD,GAAA3B,QAAA,SAAA0B,GACA,GAAAG,GAAAH,EAAAhB,MAAA,IACAmB,GAAA,KACAD,EAAAC,EAAA,IAAAA,EAAA,MAGAD,EAAA,MAAAV,EACAU,EAAA,KAAAT,EACAQ,IACA,QAAA/B,KAAAgC,GACAD,EAAAf,KAAAhB,GAAA,MAAAgC,EAAAhC,GAAA,OAAAgC,EAAAhC,IAEAyB,GAAAK,MAAAC,EAAAG,KAAA,KAEA,OAAAR,IAAAS,WAAAT,IAAAU,OAAAX,GAQA,QAAAY,GAAAC,GACAlB,GACAmB,MAAAD,IAWA,QAAAE,GAAAC,GACA,GAAAC,GAAAlB,EAAAmB,EAAAC,EAAAC,EACAC,IAEAC,KAIAL,EAAAD,KAAAzE,IAAAyE,EAAAzE,EAAAgF,SAAAP,EAAAzE,IAAAyE,EACAC,EAAA9B,MAAAqC,QAAAP,QACAC,EAAAD,EAAA3B,OAEAmC,GAAAP,EACAE,EAAAM,EAAAD,EACAN,EAAAM,EAAAC,EAEAL,EAAAM,SAAA,IAAAT,GAAAE,GAAA,EACAC,EAAAO,SAAAC,KAAAC,MAAA,IAAAX,GAGApB,EAAAiB,KAAAzE,GAAAyE,EAAAzE,EAAAwF,QAAA,KAEAV,EAAAM,WAEAK,EAAA7B,QAAAP,EAAA6B,EAAAI,KAAAI,IAAAC,EAAAd,GAAArB,GACAoC,EACAC,YAAAJ,GACAK,KAAAtB,GACAuB,MAAA1B,IAGAS,EAAAkB,KAAAC,EAAAvB,GACAtB,EAAA0B,IAlGA,GAOAW,GAPAP,EAAA,EACAgB,EAAA1D,EAAA2D,WACAhB,EAAAG,KAAAI,IAAAQ,EAAAE,OAAAC,KACAV,EAAAL,KAAAI,IAAAQ,EAAAI,WAAAD,EAAA7D,EAAA+D,WAAAF,EAAAlB,GACAJ,GAAA,EACAnB,EAAAsC,EAAAtC,QACAqC,EAAA/C,EAAAV,EA4GA,OAZAiD,IACAe,WA9FA,SAAAC,GACA,IAAAA,EAAA,QACA,IAAAC,GAAAhD,IAAAC,MAAA8C,EAQA,OAPAC,GAAAC,KAAAD,EAAAC,MAAA,GACA,MAAAD,EAAAC,KAAAC,OAAA,KACAF,EAAAC,KAAAD,EAAAC,KAAA,WAEAD,GAAA5C,YACA4C,GAAAG,WACAH,GAAAI,UACApD,IAAAS,WAAAT,IAAAU,OAAAsC,IAoFAR,EAAAM,YACA5C,QAAAP,EAAA,EAAAsC,GACAoB,OAAAb,EAAAc,SAAA,cACAC,QAAAf,EAAAe,SAGArB,EACAC,YAAAJ,GACAK,KAAAtB,GACAuB,MAAA1B,IAES6C,OAAA,WAAoBnC,GAAA,IA/M7B,GAAAa,GAAAtG,EAAA,IAEA+G,EAAA,GAgNA3G,GAAAD,SACA6B,cACAC,aAAA2B,IH6FMiE,GACA,SAAUzH,EAAQD,GIjSxB,QAAAoG,GAAAuB,GACA,mBAAAA,IAAA,OAAAA,GAAA,gBAAAA,GAAAxD,QACA,SAAAyD,OAAA,yDAGA,kBAAAD,EAAAL,QAAAK,EAAAZ,WAAAc,EAAAC,GAAAH,GAGA,QAAAG,GAAAH,GACA,UAAAI,SAAA,SAAAC,EAAAC,GACA,GAAAC,GAAA,GAAAC,eACAD,GAAAE,OAAA,WACA,GAAAC,KAAAC,QAAA,IAEA,WADAL,GAAAI,KAAAE,aAGA,KACAP,EAAAQ,KAAAtE,MAAAmE,KAAAE,eACI,MAAAE,GACJR,EAAAS,EAAAL,KAAAE,gBAGAL,EAAAS,QAAA,WACAV,EAAAW,IAEAV,EAAAW,QAAA,WACAZ,EAAAW,IAEAV,EAAAY,KAAA,MAAAnB,EAAAxD,SAAA,GACA+D,EAAAa,iBAAA,6BACAb,EAAAc,SAIA,QAAAC,KACA,6CAAAC,QAAA,iBAAA5I,GACA,GAAA6I,GAAA,GAAAtD,KAAAuD,SAAA,CACA,QADA,MAAA9I,EAAA6I,EAAA,EAAAA,EAAA,GACAE,SAAA,MAIA,QAAAxB,GAAAF,GACA,UAAAI,SAAA,SAAAC,EAAAC,GACA,GAAAC,GAAA,GAAAC,gBACAmB,EAAA,SAAAL,IACArF,EAAA+D,EAAAxD,QAAAd,MAAAsE,EAAAZ,YAAA,GACAwC,IAEArB,GAAAE,OAAA,WAMA,IALA,GAAAG,GAAAF,KAAAE,aACAiB,EAAAnB,KAAAE,aAAAlF,MAAA,QAGAoG,EAAA,EAAAC,EAAAF,EAAAlG,OAAAqG,EAAAD,EAAA,EACAD,EAAAC,GAAA,MAAAF,EAAAC,GAAAtC,MAAA,MACAsC,GAEA,MAAAE,EAAA,SAAAH,EAAAG,GAAAxC,OAAA,IACAwC,GAEAH,KAAArC,MAAAsC,EAAAE,EAAA,GACApB,EAAAiB,EAAA/E,KAAA,OAEA,KACA,GAAAmF,GAAApB,KAAAtE,MAAAqE,EACAP,GAAA4B,GACI,MAAAnB,GACJR,EAAAS,EAAAH,KAGAL,EAAAS,QAAA,WACAV,EAAAW,IAEAV,EAAAW,QAAA,WACAZ,EAAAW,IAGAV,EAAAY,KAAA,OAAAnB,EAAAZ,WAAA,aAEAmB,EAAAa,iBAAA,4BACAb,EAAAa,iBAAA,2CAAwDO,EAExD,QAAA/G,KAAAoF,GAAAH,QACA,UAAAjF,EAAAsH,eACA3B,EAAAa,iBAAAxG,EAAAoF,EAAAH,QAAAjF,GAIAgH,GAAAhG,KAAA,KAAA+F,GACAC,EAAAhG,KAAA,kCACAgG,EAAAhG,KAAA,qCACAgG,EAAAhG,KAAA,IACAgG,EAAAhG,KAAA,OAAAK,EAAA,YACA,QAAArB,KAAAoF,GAAAH,QACA+B,EAAAhG,KAAAhB,EAAA,IAAAoF,EAAAH,QAAAjF,GAEAgH,GAAAhG,KAAA,IACAgG,EAAAhG,KAAA,IACAgG,EAAAhG,KAAA,KAAA+F,EAAA,MACAC,EAAAhG,KAAA,IACAgG,IAAA9E,KAAA,QACAyD,EAAAc,KAAAO,KAlHA,GAAAX,GAAA,wBACAF,EAAA,+BAqHAzI,GAAAD,SAAkBoG,gBJwTZ0D,GACA,SAAU7J,EAAQD,GKzZxB,QAAA+B,GAAAgI,EAAAvJ,GACA,GAAAwJ,GAAAC,EAAAC,CAGAH,aAAAI,QAIAH,EAAAI,SAAAC,gBAAA,oCACAJ,EAAA,YAAAD,GAGAC,IACAC,EAAA,SAAAI,EAAAC,GACAP,EAAAQ,SAAAD,EACAP,EAAAS,KAAAC,IAAAC,gBAAAL,GACAN,EAAAY,cAAA,GAAAC,YAAA,gBAKA,KAAAX,IACAA,EAAA,SAAAI,GACA,GAAAQ,GAAA,GAAAC,WAEAD,GAAAE,UAAA,WACA,GAAAC,GAAAjE,CAEAA,GAAA8D,EAAA5H,OAAAgG,QAAA,eAA6C,0BAC7C+B,EAAAC,OAAApC,KAAA9B,EAAA,aAGAkE,OAAAC,SAAAV,KAAAzD,IAGA8D,EAAAM,cAAArB,KAUA,mBAAAsB,sBAAAC,mBACApB,EAAA,SAAAI,EAAAC,GACAW,OAAAG,UAAAC,iBAAAhB,EAAAC,KAKAL,EAAAH,EAAAvJ,IAGAP,EAAAD,SAAkB+B","file":"XLSXExportUtils.js","sourcesContent":["var XLSXExportUtils =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 33);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 33:\n/***/ (function(module, exports, __webpack_require__) {\n\n// Bundle all utilities into a single module \nvar ODataDataProvider = __webpack_require__(34);\nvar FileSaver = __webpack_require__(36);\n\nmodule.exports = {\n\toData: {\n\t\tfetch: ODataDataProvider.requestData,\n\t\tgetConverter: ODataDataProvider.getConverter\n\t},\n\tsaveFile: FileSaver.saveFile\n};\n\n/***/ }),\n\n/***/ 34:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar RequestHandler = __webpack_require__(35);\n\nvar MAX_ROWS = 1000000; // 1,000,000\n\n/**\n * OData interface for requesting chunked data.\n */\n\n/**\n * Gets converted property value from raw data.\n * Navigation properties are parsed.\n * \n * @param {Object} oRow - Raw data row\n * @param {Object} oCol - Column information\n * @param {Array} oCol.keys - Property name or key path for navigation properties\n * @param {string} oCol.type - Column data type\n * \n * @private\n */\nfunction getValue(oRow, oCol) {\n\t// Get property value\n\tvar value = oCol.keys.reduce(function (obj, key) {\n\t\treturn obj && obj[key];\n\t}, oRow);\n\n\treturn value;\n}\n\n/**\n * Function to process the JSON result array from a ODataService.\n * \n * @param {Array} aRows - Data array that contains the received data\n * @param {Array} aCols - Columns that need to be converted\n * \n * @private\n */\nfunction convertData(aRows, aCols) {\n\taCols.forEach(function (col) {\n\t\taRows.forEach(function (row) {\n\t\t\trow[col.property] = getValue(row, col);\n\t\t});\n\t});\n\treturn aRows;\n}\n\n/**\n * The function returns array of columns that need special conversion for values.\n *\n * @param {Object} mSettings - Configuration object\n * @private\n */\nfunction getColsToConvert(mSettings) {\n\treturn mSettings.workbook.columns.reduce(function (result, col) {\n\n\t\t// Handle aggregated properties and single properties\n\t\tvar properties = col.property instanceof Array ? col.property : [col.property];\n\n\t\tproperties.forEach(function(property) {\n\t\t\t// Convert navigation property and date fields\n\t\t\tvar aKeys = property.split(\"/\");\n\t\t\tif (aKeys.length > 1) {\n\t\t\t\tresult.push({\n\t\t\t\t\tproperty: property,\n\t\t\t\t\tkeys: aKeys,\n\t\t\t\t\ttype: col.type\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}, []);\n}\n\n/**\n * The function returns a conversion function for raw data.\n *\n * @param {Object} mSettings Configuration object\n * @returns {function} Conversion function\n */\nfunction getDataConverter(mSettings) {\n\tvar aColumns = getColsToConvert(mSettings);\n\treturn function(aRows) {\n\t\treturn convertData(aRows, aColumns);\n\t};\n}\n\n/**\n * The function requests several chunks of data until the maximum\n * amount of data is fetched.\n *\n * @param {Object} mSettings - Configuration object\n */\nfunction requestData(mSettings, fnProcessCallback) {\n\tvar iAvailableRows = 0;\n\tvar mDataSource = mSettings.dataSource;\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\n\tvar bCancelled = false;\n\tvar dataUrl = mDataSource.dataUrl;\n\tvar fnConvertData = getDataConverter(mSettings);\n\tvar mRequest;\n\n\tfunction cleanUrl (url) {\n\t\tif (!url) return \"\";\n\t\tvar mUri = URI.parse(url);\n\t\tmUri.path = mUri.path || \"\";\n\t\tif (mUri.path.slice(-1) !== \"/\") {\n\t\t\tmUri.path = mUri.path + \"/\";\n\t\t}\n\t\tdelete mUri.query;\n\t\tdelete mUri.hash;\n\t\tdelete mUri.fragment;\n\t\treturn (URI.serialize || URI.build)(mUri);\n\t}\n\n\t// Get download URL for the next batch\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\n\t\tvar mDataUrl = URI.parse(dataUrl);\n\t\tif (sNextUrl) { // use __next from server, replace origin if proxy was used\n\t\t\tvar mNextUrl = URI.parse(sNextUrl);\n\t\t\tmDataUrl.query = mNextUrl.query;\n\t\t} else { // use $skip and $top\n\t\t\tvar aQuery = (mDataUrl.query || \"\").split(\"&\");\n\t\t\tvar mQuery = {};\n\t\t\taQuery.forEach(function(query) {\n\t\t\t\tvar keyValue = query.split(\"=\");\n\t\t\t\tif (keyValue[0]) {\n\t\t\t\t\tmQuery[keyValue[0]] = keyValue[1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tmQuery[\"$skip\"] = iSkip;\n\t\t\tmQuery[\"$top\"] = iTop;\n\t\t\taQuery = [];\n\t\t\tfor (var key in mQuery) {\n\t\t\t\taQuery.push(key + (mQuery[key] == null ? \"\" : \"=\" + mQuery[key]));\n\t\t\t}\n\t\t\tmDataUrl.query = aQuery.join(\"&\");\n\t\t}\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\n\t}\n\n\t/**\n\t * Inner function that processes request handler exceptions.\n\t *\n\t * @param {string} sMessage - Error message.\n\t */\n\tfunction fnOnError(sMessage) {\n\t\tfnProcessCallback({\n\t\t\terror: sMessage\n\t\t});\n\t}\n\n\t/**\n\t * Inner function that processes the received data. Processing\n\t * the data before executing the callback function allows to\n\t * apply transformations to the data.\n\t *\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\n\t */\n\tfunction fnOnDataReceived(oResult) {\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\n\t\tvar mCallbackParams = {};\n\n\t\tif (bCancelled) {\n\t\t\treturn; // cancelled by the application\n\t\t}\n\n\t\taData = (oResult && oResult.d && (oResult.d.results || oResult.d)) || oResult;\n\t\taData = (Array.isArray(aData)) ? aData : [];\n\t\tiFetchedRows = aData.length;\n\n\t\tiAvailableRows += iFetchedRows;\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\n\t\tfPercent = iAvailableRows / iTotalRows;\n\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\n\n\t\t// check if next url is provided\n\t\tsNextUrl = oResult && oResult.d && oResult.d.__next || null;\n\n\t\tif (!mCallbackParams.finished) {\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\n\t\t\tRequestHandler\n\t\t\t\t.sendRequest(mRequest)\n\t\t\t\t.then(fnOnDataReceived)\n\t\t\t\t.catch(fnOnError);\n\t\t}\n\n\t\tmCallbackParams.rows = fnConvertData(aData); // normalize data\n\t\tfnProcessCallback(mCallbackParams); // Return result\n\t}\n\n\t// Execution\n\tmRequest = {\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\n\t\tdataUrl: getUrl(0, iBatchSize),\n\t\tmethod: mDataSource.useBatch ? \"BATCH\" : \"GET\",\n\t\theaders: mDataSource.headers\n\t};\n\n\tRequestHandler\n\t\t.sendRequest(mRequest)\n\t\t.then(fnOnDataReceived)\n\t\t.catch(fnOnError);\n\n\treturn {cancel: function() {bCancelled = true;}};\n}\n\nmodule.exports = {\n\trequestData: requestData,\n\tgetConverter: getDataConverter\n};\n\n/***/ }),\n\n/***/ 35:\n/***/ (function(module, exports) {\n\n/**\n * Returns a promise that is resolved once the data is fetched\n */\n\nvar HTTP_ERROR_MSG = 'HTTP connection error';\nvar HTTP_WRONG_RESPONSE_MSG = 'Unexpected server response:\\n';\n\n/**\n * This method creates an XMLHttpRequest from the provided\n * configuration and requests the data from the backend. The\n * configuration is configured to use OData services.\n *\n * @param {Object} oRequest - Request configuration object\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\n * @param {string} oRequest.url - References the resource URL that gets invoked\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\n */\nfunction sendRequest(oRequest) {\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\n\t}\n\n\treturn (oRequest.method === \"BATCH\" && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\n}\n\nfunction sendGetRequest(oRequest) {\n\treturn new Promise(function (fnResolve, fnReject) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.onload = function () {\n\t\t\tif (this.status >= 400) {\n\t\t\t\tfnReject(this.responseText);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + this.responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function () {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function () {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.open(\"GET\", oRequest.dataUrl, true);\n\t\txhr.setRequestHeader(\"accept\", \"application/json\");\n\t\txhr.send();\n\t});\n}\n\nfunction createGuid() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t\tvar r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n\t\treturn v.toString(16);\n\t});\n}\n\nfunction sendBatchRequest(oRequest) {\n\treturn new Promise(function (fnResolve, fnReject) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\tvar boundary = \"batch_\" + createGuid();\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\n\t\tvar body = [];\n\n\t\txhr.onload = function () {\n\t\t\tvar responseText = this.responseText;\n\t\t\tvar aLines = this.responseText.split(\"\\r\\n\");\n\n\t\t\t//TBD: check return codes\n\t\t\tvar iStart = 0, iLength = aLines.length, iEnd = iLength - 1;\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0,1) !== \"{\") {\n\t\t\t\tiStart++;\n\t\t\t}\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== \"}\") {\n\t\t\t\tiEnd--;\n\t\t\t}\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\n\t\t\tresponseText = aLines.join(\"\\r\\n\");\n\n\t\t\ttry {\n\t\t\t\tvar responseData = JSON.parse(responseText);\n\t\t\t\tfnResolve(responseData);\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function () {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function () {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\t// create request\n\t\txhr.open(\"POST\", oRequest.serviceUrl + \"$batch\", true);\n\n\t\txhr.setRequestHeader(\"Accept\", \"multipart/mixed\");\n\t\txhr.setRequestHeader(\"Content-Type\", \"multipart/mixed;boundary=\" + boundary);\n\n\t\tfor (var key in oRequest.headers) {\n\t\t\tif (key.toLowerCase() != \"accept\") {\n\t\t\t\txhr.setRequestHeader(key, oRequest.headers[key]);\n\t\t\t}\n\t\t}\n\n\t\tbody.push(\"--\" + boundary);\n\t\tbody.push(\"Content-Type: application/http\");\n\t\tbody.push(\"Content-Transfer-Encoding: binary\");\n\t\tbody.push(\"\");\n\t\tbody.push(\"GET \" + getUrl + \" HTTP/1.1\");\n\t\tfor (var key in oRequest.headers) {\n\t\t\tbody.push(key + \":\" + oRequest.headers[key]);\n\t\t}\n\t\tbody.push(\"\");\n\t\tbody.push(\"\");\n\t\tbody.push(\"--\" + boundary + \"--\");\n\t\tbody.push(\"\");\n\t\tbody = body.join(\"\\r\\n\");\n\t\txhr.send(body);\n\t});\n}\n\nmodule.exports = { sendRequest: sendRequest };\n\n/***/ }),\n\n/***/ 36:\n/***/ (function(module, exports) {\n\n/**\n * The FileSaver allows to save browser generated files to\n * the local computer without using a proxy service.\n *\n * This class supports the latest version of the following browsers:\n *\n * Microsoft Internet Explorer 11\n * Microsoft Edge\n * Google Chrome\n * Mozilla Firefox\n * MacOS Safari\n * iOS Safari\n * Chrome for Android\n * SAP Fiori Client\n */\n\n/**\n * This function saves the provided Blob to the local file system.\n * The parameter name is optional and depending on the browser it\n * is not ensured that the filename can be applied. Google Chrome,\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\n * apply the filename correctly.\n *\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\n * @param {string} [name] - Filename of the file including the file extension\n */\nfunction saveFile(blob, name) {\n\tvar link, downloadSupported, fnSave;\n\n\t/* Ignore other formats than Blob */\n\tif (!(blob instanceof Blob)) {\n\t\treturn;\n\t}\n\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n\tdownloadSupported = 'download' in link;\n\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\n\tif (downloadSupported) {\n\t\tfnSave = function (data, fileName) {\n\t\t\tlink.download = fileName;\n\t\t\tlink.href = URL.createObjectURL(data);\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\n\t\t}\n\t}\n\n\t/* iOS Safari, MacOS Safari */\n\tif (typeof fnSave === 'undefined') {\n\t\tfnSave = function (data) {\n\t\t\tvar reader = new FileReader();\n\n\t\t\treader.onloadend = function () {\n\t\t\t\tvar opened, url;\n\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\topened = window.open(url, '_blank');\n\n\t\t\t\tif (!opened) {\n\t\t\t\t\twindow.location.href = url;\n\t\t\t\t}\n\t\t\t};\n\t\t\treader.readAsDataURL(blob);\n\t\t}\n\t}\n\n\t/*\n\t * IE/Edge implementation\n\t *\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\n\t */\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\n\t\tfnSave = function (data, fileName) {\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\n\t\t};\n\t}\n\n\t/* Save file to device */\n\tfnSave(blob, name);\n}\n\nmodule.exports = { saveFile: saveFile };\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// XLSXExportUtils.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 33);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ec45a77245af68849c0d","// Bundle all utilities into a single module \nvar ODataDataProvider = require(\"./provider/ODataDataProvider.js\");\nvar FileSaver = require(\"./filesaver/FileSaver.js\");\n\nmodule.exports = {\n\toData: {\n\t\tfetch: ODataDataProvider.requestData,\n\t\tgetConverter: ODataDataProvider.getConverter\n\t},\n\tsaveFile: FileSaver.saveFile\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/export-utils.js\n// module id = 33\n// module chunks = 1","var RequestHandler = require('./RequestHandler.js');\n\nvar MAX_ROWS = 1000000; // 1,000,000\n\n/**\n * OData interface for requesting chunked data.\n */\n\n/**\n * Gets converted property value from raw data.\n * Navigation properties are parsed.\n * \n * @param {Object} oRow - Raw data row\n * @param {Object} oCol - Column information\n * @param {Array} oCol.keys - Property name or key path for navigation properties\n * @param {string} oCol.type - Column data type\n * \n * @private\n */\nfunction getValue(oRow, oCol) {\n\t// Get property value\n\tvar value = oCol.keys.reduce(function (obj, key) {\n\t\treturn obj && obj[key];\n\t}, oRow);\n\n\treturn value;\n}\n\n/**\n * Function to process the JSON result array from a ODataService.\n * \n * @param {Array} aRows - Data array that contains the received data\n * @param {Array} aCols - Columns that need to be converted\n * \n * @private\n */\nfunction convertData(aRows, aCols) {\n\taCols.forEach(function (col) {\n\t\taRows.forEach(function (row) {\n\t\t\trow[col.property] = getValue(row, col);\n\t\t});\n\t});\n\treturn aRows;\n}\n\n/**\n * The function returns array of columns that need special conversion for values.\n *\n * @param {Object} mSettings - Configuration object\n * @private\n */\nfunction getColsToConvert(mSettings) {\n\treturn mSettings.workbook.columns.reduce(function (result, col) {\n\n\t\t// Handle aggregated properties and single properties\n\t\tvar properties = col.property instanceof Array ? col.property : [col.property];\n\n\t\tproperties.forEach(function(property) {\n\t\t\t// Convert navigation property and date fields\n\t\t\tvar aKeys = property.split(\"/\");\n\t\t\tif (aKeys.length > 1) {\n\t\t\t\tresult.push({\n\t\t\t\t\tproperty: property,\n\t\t\t\t\tkeys: aKeys,\n\t\t\t\t\ttype: col.type\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}, []);\n}\n\n/**\n * The function returns a conversion function for raw data.\n *\n * @param {Object} mSettings Configuration object\n * @returns {function} Conversion function\n */\nfunction getDataConverter(mSettings) {\n\tvar aColumns = getColsToConvert(mSettings);\n\treturn function(aRows) {\n\t\treturn convertData(aRows, aColumns);\n\t};\n}\n\n/**\n * The function requests several chunks of data until the maximum\n * amount of data is fetched.\n *\n * @param {Object} mSettings - Configuration object\n */\nfunction requestData(mSettings, fnProcessCallback) {\n\tvar iAvailableRows = 0;\n\tvar mDataSource = mSettings.dataSource;\n\tvar iTotalRows = Math.min(mDataSource.count || MAX_ROWS, MAX_ROWS);\n\tvar iBatchSize = Math.min(mDataSource.sizeLimit || MAX_ROWS, mSettings.batchSize || MAX_ROWS, iTotalRows);\n\tvar bCancelled = false;\n\tvar dataUrl = mDataSource.dataUrl;\n\tvar fnConvertData = getDataConverter(mSettings);\n\tvar mRequest;\n\n\tfunction cleanUrl (url) {\n\t\tif (!url) return \"\";\n\t\tvar mUri = URI.parse(url);\n\t\tmUri.path = mUri.path || \"\";\n\t\tif (mUri.path.slice(-1) !== \"/\") {\n\t\t\tmUri.path = mUri.path + \"/\";\n\t\t}\n\t\tdelete mUri.query;\n\t\tdelete mUri.hash;\n\t\tdelete mUri.fragment;\n\t\treturn (URI.serialize || URI.build)(mUri);\n\t}\n\n\t// Get download URL for the next batch\n\tfunction getUrl(iSkip, iTop, sNextUrl) {\n\t\tvar mDataUrl = URI.parse(dataUrl);\n\t\tif (sNextUrl) { // use __next from server, replace origin if proxy was used\n\t\t\tvar mNextUrl = URI.parse(sNextUrl);\n\t\t\tmDataUrl.query = mNextUrl.query;\n\t\t} else { // use $skip and $top\n\t\t\tvar aQuery = (mDataUrl.query || \"\").split(\"&\");\n\t\t\tvar mQuery = {};\n\t\t\taQuery.forEach(function(query) {\n\t\t\t\tvar keyValue = query.split(\"=\");\n\t\t\t\tif (keyValue[0]) {\n\t\t\t\t\tmQuery[keyValue[0]] = keyValue[1];\n\t\t\t\t}\n\t\t\t});\n\t\t\tmQuery[\"$skip\"] = iSkip;\n\t\t\tmQuery[\"$top\"] = iTop;\n\t\t\taQuery = [];\n\t\t\tfor (var key in mQuery) {\n\t\t\t\taQuery.push(key + (mQuery[key] == null ? \"\" : \"=\" + mQuery[key]));\n\t\t\t}\n\t\t\tmDataUrl.query = aQuery.join(\"&\");\n\t\t}\n\t\treturn (URI.serialize || URI.build)(mDataUrl);\n\t}\n\n\t/**\n\t * Inner function that processes request handler exceptions.\n\t *\n\t * @param {string} sMessage - Error message.\n\t */\n\tfunction fnOnError(sMessage) {\n\t\tfnProcessCallback({\n\t\t\terror: sMessage\n\t\t});\n\t}\n\n\t/**\n\t * Inner function that processes the received data. Processing\n\t * the data before executing the callback function allows to\n\t * apply transformations to the data.\n\t *\n\t * @param {Object} oResult - The result object that is provided by the Promise resolve.\n\t */\n\tfunction fnOnDataReceived(oResult) {\n\t\tvar aData, sNextUrl, iFetchedRows, fPercent, iRemainingRows;\n\t\tvar mCallbackParams = {};\n\n\t\tif (bCancelled) {\n\t\t\treturn; // cancelled by the application\n\t\t}\n\n\t\taData = (oResult && oResult.d && (oResult.d.results || oResult.d)) || oResult;\n\t\taData = (Array.isArray(aData)) ? aData : [];\n\t\tiFetchedRows = aData.length;\n\n\t\tiAvailableRows += iFetchedRows;\n\t\tiRemainingRows = iTotalRows - iAvailableRows;\n\t\tfPercent = iAvailableRows / iTotalRows;\n\n\t\tmCallbackParams.finished = iFetchedRows === 0 || iRemainingRows <= 0; // Done criteria\n\t\tmCallbackParams.progress = Math.round(fPercent * 100);\n\n\t\t// check if next url is provided\n\t\tsNextUrl = oResult && oResult.d && oResult.d.__next || null;\n\n\t\tif (!mCallbackParams.finished) {\n\t\t\t// Trigger next page request before processing received data. Fetch only configured/max limit rows\n\t\t\tmRequest.dataUrl = getUrl(iAvailableRows, Math.min(iBatchSize, iRemainingRows), sNextUrl);\n\t\t\tRequestHandler\n\t\t\t\t.sendRequest(mRequest)\n\t\t\t\t.then(fnOnDataReceived)\n\t\t\t\t.catch(fnOnError);\n\t\t}\n\n\t\tmCallbackParams.rows = fnConvertData(aData); // normalize data\n\t\tfnProcessCallback(mCallbackParams); // Return result\n\t}\n\n\t// Execution\n\tmRequest = {\n\t\tserviceUrl: cleanUrl(mDataSource.serviceUrl),\n\t\tdataUrl: getUrl(0, iBatchSize),\n\t\tmethod: mDataSource.useBatch ? \"BATCH\" : \"GET\",\n\t\theaders: mDataSource.headers\n\t};\n\n\tRequestHandler\n\t\t.sendRequest(mRequest)\n\t\t.then(fnOnDataReceived)\n\t\t.catch(fnOnError);\n\n\treturn {cancel: function() {bCancelled = true;}};\n}\n\nmodule.exports = {\n\trequestData: requestData,\n\tgetConverter: getDataConverter\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/ODataDataProvider.js\n// module id = 34\n// module chunks = 1","/**\n * Returns a promise that is resolved once the data is fetched\n */\n\nvar HTTP_ERROR_MSG = 'HTTP connection error';\nvar HTTP_WRONG_RESPONSE_MSG = 'Unexpected server response:\\n';\n\n/**\n * This method creates an XMLHttpRequest from the provided\n * configuration and requests the data from the backend. The\n * configuration is configured to use OData services.\n *\n * @param {Object} oRequest - Request configuration object\n * @param {string} oRequest.method - References the HTTP method that is used (default: GET)\n * @param {string} oRequest.url - References the resource URL that gets invoked\n * @return {Promise} Returns a Promise that will be resolve once the requested data was fetched\n */\nfunction sendRequest(oRequest) {\n\tif (typeof oRequest !== 'object' || oRequest === null || typeof oRequest.dataUrl !== 'string') {\n\t\tthrow new Error('Unable to send request - Mandatory parameters missing.');\n\t}\n\n\treturn (oRequest.method === \"BATCH\" && oRequest.serviceUrl ? sendBatchRequest : sendGetRequest)(oRequest);\n}\n\nfunction sendGetRequest(oRequest) {\n\treturn new Promise(function (fnResolve, fnReject) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.onload = function () {\n\t\t\tif (this.status >= 400) {\n\t\t\t\tfnReject(this.responseText);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfnResolve(JSON.parse(this.responseText));\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + this.responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function () {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function () {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.open(\"GET\", oRequest.dataUrl, true);\n\t\txhr.setRequestHeader(\"accept\", \"application/json\");\n\t\txhr.send();\n\t});\n}\n\nfunction createGuid() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t\tvar r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n\t\treturn v.toString(16);\n\t});\n}\n\nfunction sendBatchRequest(oRequest) {\n\treturn new Promise(function (fnResolve, fnReject) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\tvar boundary = \"batch_\" + createGuid();\n\t\tvar getUrl = oRequest.dataUrl.split(oRequest.serviceUrl)[1];\n\t\tvar body = [];\n\n\t\txhr.onload = function () {\n\t\t\tvar responseText = this.responseText;\n\t\t\tvar aLines = this.responseText.split(\"\\r\\n\");\n\n\t\t\t//TBD: check return codes\n\t\t\tvar iStart = 0, iLength = aLines.length, iEnd = iLength - 1;\n\t\t\twhile (iStart < iLength && aLines[iStart].slice(0,1) !== \"{\") {\n\t\t\t\tiStart++;\n\t\t\t}\n\t\t\twhile (iEnd > 0 && aLines[iEnd].slice(-1) !== \"}\") {\n\t\t\t\tiEnd--;\n\t\t\t}\n\t\t\taLines = aLines.slice(iStart, iEnd + 1);\n\t\t\tresponseText = aLines.join(\"\\r\\n\");\n\n\t\t\ttry {\n\t\t\t\tvar responseData = JSON.parse(responseText);\n\t\t\t\tfnResolve(responseData);\n\t\t\t} catch (e) {\n\t\t\t\tfnReject(HTTP_WRONG_RESPONSE_MSG + responseText);\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function () {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\txhr.onabort = function () {\n\t\t\tfnReject(HTTP_ERROR_MSG);\n\t\t};\n\t\t// create request\n\t\txhr.open(\"POST\", oRequest.serviceUrl + \"$batch\", true);\n\n\t\txhr.setRequestHeader(\"Accept\", \"multipart/mixed\");\n\t\txhr.setRequestHeader(\"Content-Type\", \"multipart/mixed;boundary=\" + boundary);\n\n\t\tfor (var key in oRequest.headers) {\n\t\t\tif (key.toLowerCase() != \"accept\") {\n\t\t\t\txhr.setRequestHeader(key, oRequest.headers[key]);\n\t\t\t}\n\t\t}\n\n\t\tbody.push(\"--\" + boundary);\n\t\tbody.push(\"Content-Type: application/http\");\n\t\tbody.push(\"Content-Transfer-Encoding: binary\");\n\t\tbody.push(\"\");\n\t\tbody.push(\"GET \" + getUrl + \" HTTP/1.1\");\n\t\tfor (var key in oRequest.headers) {\n\t\t\tbody.push(key + \":\" + oRequest.headers[key]);\n\t\t}\n\t\tbody.push(\"\");\n\t\tbody.push(\"\");\n\t\tbody.push(\"--\" + boundary + \"--\");\n\t\tbody.push(\"\");\n\t\tbody = body.join(\"\\r\\n\");\n\t\txhr.send(body);\n\t});\n}\n\nmodule.exports = { sendRequest: sendRequest };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/provider/RequestHandler.js\n// module id = 35\n// module chunks = 1","/**\n * The FileSaver allows to save browser generated files to\n * the local computer without using a proxy service.\n *\n * This class supports the latest version of the following browsers:\n *\n * Microsoft Internet Explorer 11\n * Microsoft Edge\n * Google Chrome\n * Mozilla Firefox\n * MacOS Safari\n * iOS Safari\n * Chrome for Android\n * SAP Fiori Client\n */\n\n/**\n * This function saves the provided Blob to the local file system.\n * The parameter name is optional and depending on the browser it\n * is not ensured that the filename can be applied. Google Chrome,\n * Mozilla Firefox, Internet Explorer and Microsoft Edge will\n * apply the filename correctly.\n *\n * @param {Blob} blob - Binary large object of the file that should be saved to the filesystem\n * @param {string} [name] - Filename of the file including the file extension\n */\nfunction saveFile(blob, name) {\n\tvar link, downloadSupported, fnSave;\n\n\t/* Ignore other formats than Blob */\n\tif (!(blob instanceof Blob)) {\n\t\treturn;\n\t}\n\n\tlink = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');\n\tdownloadSupported = 'download' in link;\n\n\t/* Try ObjectURL Chrome, Firefox, Opera, Android, Safari (Desktop ab 10.1) */\n\tif (downloadSupported) {\n\t\tfnSave = function (data, fileName) {\n\t\t\tlink.download = fileName;\n\t\t\tlink.href = URL.createObjectURL(data);\n\t\t\tlink.dispatchEvent(new MouseEvent('click'));\n\t\t}\n\t}\n\n\t/* iOS Safari, MacOS Safari */\n\tif (typeof fnSave === 'undefined') {\n\t\tfnSave = function (data) {\n\t\t\tvar reader = new FileReader();\n\n\t\t\treader.onloadend = function () {\n\t\t\t\tvar opened, url;\n\n\t\t\t\turl = reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\topened = window.open(url, '_blank');\n\n\t\t\t\tif (!opened) {\n\t\t\t\t\twindow.location.href = url;\n\t\t\t\t}\n\t\t\t};\n\t\t\treader.readAsDataURL(blob);\n\t\t}\n\t}\n\n\t/*\n\t * IE/Edge implementation\n\t *\n\t * Microsoft Edge also supports the download attribute but ignores the value of the attribute.\n\t * This is why we override it with the navigator.msSaveOrOpenBlob function in case of MS Edge.\n\t */\n\tif (typeof navigator !== 'undefined' && navigator.msSaveOrOpenBlob) {\n\t\tfnSave = function (data, fileName) {\n\t\t\twindow.navigator.msSaveOrOpenBlob(data, fileName);\n\t\t};\n\t}\n\n\t/* Save file to device */\n\tfnSave(blob, name);\n}\n\nmodule.exports = { saveFile: saveFile };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/src/filesaver/FileSaver.js\n// module id = 36\n// module chunks = 1"],"sourceRoot":""}